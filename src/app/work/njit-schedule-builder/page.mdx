# NJIT Auto Schedule Builder

A Python + Flask service that transforms NJIT's complex course catalog into a clean, accessible API for students to build optimal schedules.

## The Challenge

NJIT students faced a frustrating course registration experience:
- Raw JavaScript payloads from the university's system were difficult to parse
- No way to automatically generate conflict-free schedules
- Manual schedule building was time-consuming and error-prone
- Limited filtering options for time preferences and day-of-week constraints

## Technical Approach

### Backend Architecture

Built a robust Flask service that handles the entire data pipeline:

<TechStack>
<Tech>Python</Tech>
<Tech>Flask</Tech>
<Tech>REST API</Tech>
<Tech>Web Scraping</Tech>
</TechStack>

**Data Processing Pipeline:**
1. **Scraping Layer** - Automated extraction of course data from NJIT's catalog
2. **Parser Engine** - Converts messy JavaScript payloads to clean JSON
3. **REST API** - Serves structured course and section data
4. **Combinatorial Solver** - Generates clash-free schedule combinations

### Frontend Experience

Created an intuitive interface for schedule building:

<TechStack>
<Tech>HTML5</Tech>
<Tech>CSS3</Tech>
<Tech>Vanilla JavaScript</Tech>
<Tech>Responsive Design</Tech>
</TechStack>

**Key Features:**
- Time-range input controls for availability preferences
- Day-of-week filters for flexible scheduling
- Sequential schedule preview with conflict detection
- Clean, mobile-responsive design

## Algorithm Design

The core scheduling algorithm uses constraint satisfaction:

```python
def generate_schedules(courses, constraints):
    """
    Generate all possible conflict-free schedules
    given course requirements and user constraints
    """
    valid_schedules = []
    
    for combination in itertools.product(*course_sections):
        if not has_time_conflicts(combination):
            if meets_constraints(combination, constraints):
                valid_schedules.append(combination)
    
    return sorted(valid_schedules, key=schedule_score)
```

## Impact & Results

**Student Experience:**
- Reduced schedule planning time from hours to minutes
- Eliminated manual conflict checking
- Provided multiple optimal schedule options

**Technical Achievements:**
- 100% uptime during peak registration periods
- Sub-second response times for schedule generation
- Clean API design adopted by other student developers

## What I Learned

This project taught me valuable lessons about:
- **Data Pipeline Design** - Building robust systems that handle messy external data
- **Algorithm Optimization** - Balancing completeness with performance in combinatorial problems
- **User-Centered Design** - Creating interfaces that solve real student pain points
- **API Design** - Building clean, documented endpoints that others can build upon

## Next Steps

If I were to continue this project, I would:
- Add GraphQL endpoint for more flexible data querying
- Implement caching layer for improved performance
- Build mobile app with push notifications for seat availability
- Add machine learning for schedule preference learning
- Create admin dashboard for monitoring and analytics

---

*This project demonstrates my ability to build full-stack solutions that solve real-world problems, from data processing to user experience.*
